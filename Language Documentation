# AZKABan Documentation
## 1) Lexical analysis:<br/>
### 1.1) Physical lines:<br/>
A physical line is a sequence of characters which terminate at an end-of-line sequence. An AZKABan program is a set of such lines. The end of a program is marked by an EOF token.<br/>
### 1.2) Comments:<br/>
Comments are enclosed within a pair of curly brackets {}. Comments are ignored by the syntax.<br/>
### 1.3) Blank lines:<br/>
A line that contains only spaces and tabs is ignored.<br/>
### 1.4) White spaces:<br/>
White spaces are ignored everywhere in the program. Spaces at the beginning of each line are also ignored hence they do not imply the different indentation levels.<br/>
## 2) tokens:<br/>
### 2.1) Identifiers:<br/>
The valid characters for identifiers only include alphabets both lowercase and uppercase and digits from 0 to 9. The first character must not be a digit. Case is significant.<br/>
### 2.2) Keywords:<br/>
The following keywords are reserved and cannot be used as identifiers: BEGIN, END, IF, THEN, ELSE, TRUE, FALSE, WHILE, DO.<br/>
### 2.3) Literals:<br/>
Literals are constant values of some built-in types.<br/>
#### 2.3.a) StringLiterals:<br/>
These are a sequence of characters defined within quotes, eg: ”azkaban”.<br/>
#### 2.3.b) NumLiterals:<br/>
These are integers as per the mathematical definition. Examples: 1, 7, 100.<br/>
### 2.4) Operators:<br/>
The following tokens are operators: + &nbsp; - &nbsp; / &nbsp; * &nbsp; %(modulo) &nbsp; @(power) &nbsp; > &nbsp; < &nbsp; >= &nbsp; <= &nbsp; =<br/>
### 2.5) Delimiters:<br/>
( &nbsp; ) &nbsp; . &nbsp; ; &nbsp; , &nbsp; : &nbsp; etc. act as delimiters in the grammar.<br/>
## 3) Data Model:<br/>
### 3.1) Objects:<br/>
Objects are an abstraction for data. Every object has a type and a value. Depending on whether the value of the object changes, it can be classified as mutable or immutable.<br/>
### 3.2) Standard types:<br/>
The built-in data types are given below:<br/>
#### 3.2.a) NumLiteral:<br/>
These are implemented as fractions of the form a/b. A sign is shown if it is negative only.<br/>
#### 3.2.b) BoolLiteral:<br/>
These can only hold the truth values True and False.<br/>
#### 3.2.c) StringLiteral:<br/>
These can hold a sequence of characters. They are enclosed within double quotation marks(”).<br/>
## 4) Execution Model:<br/>
### 4.1) Structure:<br/>
The lines constituting a program are separated into blocks. Each block is an atomic unit and executed as such.<br/>
### 4.2) Naming and Binding:<br/>
Each name refers to an object. The data type of identifiers are not declared explicitly. They are identified by the value that the identifier refers to.<br/>
### 4.3) Scoping:<br/>
Scope defines the visibility of a name. A name is resolved using the nearest enclosing scope. Set of all scopes visible to a block is known as its environment. The scope extends to any block within the block in which it is defined. A block is enclosed within BEGIN and END tokens.<br/>
### 4.4) Exception:<br/>
When an invalid token is generated by the lexer it stops the program and throws an error message.<br/>
## 5) Expressions:<br/>
### 5.1) Arithmetic:<br/>
#### 5.1.1) Unary operations:<br/>
The BNF grammar notation for a Unary expression is given below:<br/>
expr ::= expr | (-)expr | (+)expr<br/>
#### 5.1.2) Binary operations:<br/>
The common binary operations that are addition, subtraction, division and   multiplication are implemented in AZKABan. In order to account for precedence and use of parentheses, the grammar including unary operations is defined as follows:<br/>
precedence3 ::= integer | ( precedence1 ) | identifier | (+/-) precedence3<br/>
exponential : precedence3 | precedence3 @ precedence3<br/>
precedence2 ::= precedence3 | precedence3 (* or /) precedence3<br/>
precedence1 ::= precedence2 | precedence2 (+/-) precedence2<br/>
### 5.2) Assignment expressions:<br/>
The identifiers are assigned values using ‘:=’, for example- i := 1 implies the NumLiteral1 is assigned to i.<br/>
### 5.3) Comparison expressions:<br/>
The following comparison operators are valid:<br/>
> &nbsp; < &nbsp; >= &nbsp; <= &nbsp; = &nbsp; <><br/>
### 5.4) Concatenation:<br/>
The operator + performs different operations on different data types. While it performs arithmetic addition on integers. It performs concatenation on strings.<br/>
### 5.5) I/O operations:<br/>
The keyword PRINT is used to display values on screen:<br/>
Eg: PRINT 2+3 END; (Here ‘END;’ serves the purpose of end-of-line. It is not necessary to have a begin for a single statement)<br/>
## 6) Control Flow:<br/>
### 6.1) IF statement:<br/>
If statements are used to check conditions to determine flow. If else statements follow the below structure:<br/>
IF (condition) (statement list_1) ELSE (statement list_2)<br/>
Eg: IF a>3<br/>
&nbsp; &nbsp; &nbsp; BEGIN<br/>
&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; PRINT “ON” END;<br/>
&nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; b := -1 END;<br/>
&nbsp; &nbsp; &nbsp; END<br/>
&nbsp; &nbsp; &nbsp; ELSE<br/>
&nbsp; &nbsp; &nbsp; PRINT “OFF” END;<br/>
### 6.2) WHILE loop:<br/>
While is used to execute the same set of statements until the condition is no longer true. It follows the below structure:<br/>
WHILE (condition) DO (statement list)<br/><br/>
Eg: WHILE i<10<br/>
&nbsp; &nbsp; &nbsp; DO<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j := j * i;<br/> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<br/>
&nbsp; &nbsp; &nbsp; END;<br/>
### 6.3) FOR loop:<br/>
The FOR keyword is followed by three expressions: init-expression ; cond-expression ; loop-expression similar to c++.<br/>
Eg:<br/>
p:=1;<br/>
q:=1;<br/>
FOR i:= 1 ; i < 126 ; i := i + 1<br/>
DO<br/>
&nbsp; &nbsp; &nbsp; BEGIN<br/>
&nbsp; &nbsp; &nbsp; q:=q * p;<br/>
&nbsp; &nbsp; &nbsp; p:=p + 1;<br/>        
&nbsp; &nbsp; &nbsp; PRINT q END;<br/>
&nbsp; &nbsp; &nbsp; PRINT i END;<br/>
&nbsp; &nbsp; &nbsp; END<br/>
END;<br/>
### 6.4) BREAK statement:<br/>
The break statement breaks out of the current for or while loop.<br/>
### 6.5) FUNCTION definitions:<br/>
A function definition is used to define a user-defined function object. The FUNCTION keyword is followed by a list of parameters. It is then followed by a sequence of executable statements. It is executed during a function call.<br/>
Eg:<br/> 
FUNCTION add(a,b)<br/>
&nbsp; &nbsp; &nbsp; BEGIN<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c:=a+b;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN c;<br/>
&nbsp; &nbsp; &nbsp; END;<br/>
